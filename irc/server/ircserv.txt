
===========================
		COMMANDS
===========================
to connect, run:
`nc <ip address> <port>`
//Netcat (nc) is a raw TCP/UDP tool that allows direct communication with network services without modifying data. It is often used for port scanning, debugging, and data transfer. Unlike e.g. Telnet, Netcat does not interpret control sequences, making it better for binary data transmission


===========================
		FUNCTIONS
===========================
-htons() 	host to network short - byte reordering, if necessary (just pass the ports to one of these always, it won't hurt)
-htonl() 	host to network long
-ntohs() 	network to host short
-ntohl()	network to host long
-pton()		printable to network


		SYSCALLS:
- getaddrinfo()
- getnameinfo() - inverse of getaddrinfo(3): it converts a socket address to a corresponding host and service, in a protocol-independent manner.
- socket() //use PF_INET instead of AF_INET as the domain, despite both basically being same
- bind () //once there is a socket, you bind it to a port
- connect() -initiate a connection on a socket
- listen()
- accept()
- send - send, sendto, sendmsg - send a message on a socket (basically write() with flags)
- recv - recv, recvfrom, recvmsg - receive a message from a socket (basically read() with flags)
- close() and shutdown()
- getpeername() and gethostname()


===========================
		  THEORY BASIC
===========================

-Socket is a way to speak to other programs using standard Unix file descriptors.

-There are Internet sockets, UNIX sockets, X.25 sockets, etc.

-Internet sockets have Stream sockets, Datagram sockets, Raw sockets, etc. 
-Telnet or ssh use Stream sockets
-Stream sockets use Transmission Control Protocol (TCP)
-Datagram sockets use User Datagram Protocol (UDP) and are often connectionless, not needing to maintain a connection 
-It’s way faster to fire-and-forget than it is to keep track of what has arrived safely and make sure it’s in order and all that. If you’re sending chat messages, TCP is great; if you’re sending 40 positional updates per second of the players in the world, maybe it doesn’t matter so much if one or two get dropped, and UDP is a good choice.
-Basically, a packet is wrapped (“encapsulated”) in a header (and rarely a footer) by the first protocol (say, the TFTP -Trivial File Transfer Protocol), then the whole thing (TFTP header included) is encapsulated again by the next protocol (say, UDP), then again by the next (IP), then again by the final protocol on the hardware (physical) layer (say, Ethernet). When another computer receives the packet, the hardware strips the Ethernet header, the kernel strips the IP and UDP headers, the TFTP program strips the TFTP header, and it finally has the data.

-TCP and UDP use two addresses: IP (Internet Protocol), and Port number. Port number is a 16-bit number that’s like the local address for the connection.

-Say you want to have a computer that handles incoming mail AND web services—how do you differentiate between the two on a computer with a single IP address?
Well, different services on the Internet have different well-known port numbers. You can see them all in the Big IANA Port List16 or, if you’re on a Unix box, in your /etc/services file. HTTP (the web) is port 80, telnet is port 23, SMTP is port 25, and so on.
Ports under 1024 are often considered special, and usually require special OS privileges to use. 
-Sockets bind to ports. A port is like a mailbox: It’s a designated location where messages arrive. A socket is like a phone call: Once you pick up (accept a connection), the two parties can talk to each other using that established connection.
So ports are entry points, and sockets are active connections (A UDP socket binds to a port so other devices can send packets to it, but it does not maintain a persistent link.).

-Byte order can be Big Endian (b34f - b3 byte stored first, 4f second), and little endian (opposite). Big is "Network Byte Order" and the little is "Host Byte order"


-Socket interface data types:
	-socket descriptor - an int 
	-struct addrinfo {
		int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
		int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
		int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
		int              ai_protocol;  // use 0 for "any"
		size_t           ai_addrlen;   // size of ai_addr in bytes
		struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
		char            *ai_canonname; // full canonical hostname

		struct addrinfo *ai_next;      // linked list, next node
	};
	addrinfo structure is a more recent invention, and is used to prep the socket address structures for subsequent use. It’s also used in host name lookups, and service name lookups. That’ll make more sense later when we get to actual usage, but just know for now that it’s one of the first things you’ll call when making a connection
	You might not usually need to write to these structures; oftentimes, a call to getaddrinfo() to fill out your struct addrinfo for you is all you’ll need. You will, however, have to peer inside these structs to get the values out.
	-struct sockaddr {
		unsigned short    sa_family;    // address family, AF_xxx
		char              sa_data[14];  // 14 bytes of protocol address
	}; 
	sa_family can be a variety of things, but it’ll be AF_INET (IPv4) or AF_INET6 (IPv6) for irc.
	sa_data contains a destination address and port number for the socket. This is rather unwieldy since you don’t want to tediously pack the address in the sa_data by hand.
	To deal with struct sockaddr, programmers created a parallel structure: struct sockaddr_in (“in” for “Internet”) to be used with IPv4.	
	And this is the important bit: a pointer to a struct sockaddr_in can be cast to a pointer to a struct sockaddr and vice-versa. So even though connect() wants a struct sockaddr*, you can still use a struct sockaddr_in and cast it at the last minute!
	-struct sockaddr_in {
		short int          sin_family;  // Address family, AF_INET
		unsigned short int sin_port;    // Port number
		struct in_addr     sin_addr;    // Internet address
		unsigned char      sin_zero[8]; // Same size as struct sockaddr
	}; // (see struct sockaddr_in6 for IPv6)
	
- let’s say you have a struct sockaddr_in ina, and you have an IP address “10.12.110.57” or “2001:db8:63b3:1::3490” that you want to store into it. The function you want to use, inet_pton(), converts an IP address in numbers-and-dots notation into either a struct in_addr or a struct in6_addr depending on whether you specify AF_INET or AF_INET6. (“pton” stands for “presentation to network”—you can call it “printable to network” if that’s easier to remember.)
	struct sockaddr_in sa; // IPv4
	struct sockaddr_in6 sa6; // IPv6

	inet_pton(AF_INET, "10.12.110.57", &(sa.sin_addr)); // IPv4
	inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &(sa6.sin6_addr)); // IPv6



Signals from socket():
"A SIGPIPE signal is raised if a process sends or receives on a broken stream; this causes naive processes, which do not handle the signal, to exit."


===========================
	  THEORY HIGH LEVEL
===========================
examples:
    Create all the necessary classes and methods for the project
    Create a socket and handle the server signals.
    Use the poll() function to check if an event has occurred.
    If the event is a new client, register it.
    If the event is data from a registered client, handle it.
    
The ADAPTIVE Communication Environment (ACE) is a 1993 framework that implements many core patterns for concurrent communication software (used by NASA, Motorola Iridium etc). Mostly adopted by now in modern c++ and functions like epoll(). 

    void logging_server (void) {
		initialize acceptor endpoint
		loop forever {
			wait for events
			handle data events
			handle connection events
		}
	}

To start listening, you make the socket(), bind() it to local address, listen(), and then run accept(). 
"If no pending connections are present on the queue, and the socket
       is not marked as nonblocking, accept() blocks the caller until a
       connection is present.  If the socket is marked nonblocking and no
       pending connections are present on the queue, accept() fails with
       the error EAGAIN or EWOULDBLOCK.
       In order to be notified of incoming connections on a socket, you
       can use select(2), poll(2), or epoll(7).  A readable event will be
       delivered when a new connection is attempted and you may then call
       accept() to get a socket for that connection."

GPT about move semantics:
When your class owns a resource (like memory, a file descriptor, a socket…), 
copying that class usually requires a deep copy of the resource. But sometimes, 
you don’t want to copy, you want to transfer the ownership, like in this case:
```std::vector<Socket> vec;
vec.push_back(Socket()); // Here, a temporary Socket is created and moved into the vector```



https://www.scottklement.com/rpg/socktut/nonblocking.html:
```
6.5. Blocking vs. non-blocking sockets

So far in this chapter, you've seen that select() can be used to detect when data is available to read from a socket. However, there are times when its useful to be able to call send(), recv(), connect(), accept(), etc without having to wait for the result.

For example, let's say that you're writing a web browser. You try to connect to a web server, but the server isn't responding. When a user presses (or clicks) a stop button, you want the connect() API to stop trying to connect.

With what you've learned so far, that can't be done. When you issue a call to connect(), your program doesn't regain control until either the connection is made, or an error occurs.

The solution to this problem is called "non-blocking sockets".

By default, TCP sockets are in "blocking" mode. For example, when you call recv() to read from a stream, control isn't returned to your program until at least one byte of data is read from the remote site. This process of waiting for data to appear is referred to as "blocking". The same is true for the write() API, the connect() API, etc. When you run them, the connection "blocks" until the operation is complete.

Its possible to set a descriptor so that it is placed in "non-blocking" mode. When placed in non-blocking mode, you never wait for an operation to complete. This is an invaluable tool if you need to switch between many different connected sockets, and want to ensure that none of them cause the program to "lock up."

If you call "recv()" in non-blocking mode, it will return any data that the system has in it's read buffer for that socket. But, it won't wait for that data. If the read buffer is empty, the system will return from recv() immediately saying ``"Operation Would Block!"''.

The same is true of the send() API. When you call send(), it puts the data into a buffer, and as it's read by the remote site, it's removed from the buffer. If the buffer ever gets "full", the system will return the error 'Operation Would Block" the next time you try to write to it.

Non-blocking sockets have a similar effect on the accept() API. When you call accept(), and there isn't already a client connecting to you, it will return 'Operation Would Block', to tell you that it can't complete the accept() without waiting...

The connect() API is a little different. If you try to call connect() in non-blocking mode, and the API can't connect instantly, it will return the error code for 'Operation In Progress'. When you call connect() again, later, it may tell you 'Operation Already In Progress' to let you know that it's still trying to connect, or it may give you a successful return code, telling you that the connect has been made.

Going back to the "web browser" example, if you put the socket that was connecting to the web server into non-blocking mode, you could then call connect(), print a message saying "connecting to host www.floofy.com..." then maybe do something else, and them come back to connect() again. If connect() works the second time, you might print "Host contacted, waiting for reply..." and then start calling send() and recv(). If the connect() is still pending, you might check to see if the user has pressed a "abort" button, and if so, call close() to stop trying to connect.

Non-blocking sockets can also be used in conjunction with the select() API. In fact, if you reach a point where you actually WANT to wait for data on a socket that was previously marked as "non-blocking", you could simulate a blocking recv() just by calling select() first, followed by recv().

The "non-blocking" mode is set by changing one of the socket's "flags". The flags are a series of bits, each one representing a different capability of the socket. So, to turn on non-blocking mode requires three steps:

    Call the fcntl() API to retrieve the socket descriptor's current flag settings into a local variable.

    In our local variable, set the O_NONBLOCK (non-blocking) flag on. (being careful, of course, not to tamper with the other flags)

    Call the fcntl() API to set the flags for the descriptor to the value in our local variable.
    ```


-If O_NONBLOCK is set and the STREAM cannot accept data, write() shall return -1 and set errno to [EAGAIN].
-If O_NONBLOCK is set and part of the buffer has been written while a condition in which the STREAM cannot accept additional data occurs, write() shall terminate and return the number of bytes written




- How do I use TCP_NODELAY?
  First off, be sure you really want to use it in the first place.  It
  will disable the Nagle algorithm (see ``2.11 How can I force a socket
  to send the data in its buffer?''), which will cause network traffic
  to increase, with smaller than needed packets wasting bandwidth.
  Also, from what I have been able to tell, the speed increase is very
  small, so you should probably do it without TCP_NODELAY first, and
  only turn it on if there is a problem.

  Here is a code example, with a warning about using it from Andrew
  Gierth:

         int flag = 1;
         int result = setsockopt(sock,            /* socket affected */
                                 IPPROTO_TCP,     /* set option at TCP level */
                                 TCP_NODELAY,     /* name of option */
                                 (char *) &flag,  /* the cast is historical
                                                         cruft */
                                 sizeof(int));    /* length of option value */
         if (result < 0)
            ... handle the error ...

  TCP_NODELAY is for a specific purpose; to disable the Nagle buffering
  algorithm. It should only be set for applications that send frequent
  small bursts of information without getting an immediate response,
  where timely delivery of data is required (the canonical example is
  mouse movements).

[an error occurred while processing this directive]
